---
title: "Differential Abundance Analysis: Humann3"
author: "David Fischer"
date: "04.02.2022"
output: html_document
params:
  counts: "/home/david/bachelorarbeit/metagenomics/assets/genefamilies_cpm_combined.tsv"
  metadata: "/home/david/bachelorarbeit/metagenomics/assets/SraRunTable.txt"
  show_code: TRUE
  comparisons: "/home/david/bachelorarbeit/metagenomics/assets/contrast.csv"
  formula: "sex+antibiotic_12m+Fam_hx_stone+diet_type"
  cpus: 8
  abundance_threshold: 10
  prevalence_threshold: 0.0001
  alpha: 0.9
  fc_threshold: 1
  work_dir: "/home/david/abundance_analysis"
  plot_height: 11 
  plot_width: 11
---

```{r setup, include=FALSE}
# run with: Rscript -e "rmarkdown::render('differential_abundance_humann.Rmd',params=list(counts = '', metadata = ''))"
knitr::opts_chunk$set(echo = TRUE)

# set directory variables
out_dir_gen <-paste(params$work_dir, "Overview", sep = "/")
out_dir_gen_plots <-paste(out_dir_gen, "Plots", sep = "/")
out_dir_gen_data <-paste(out_dir_gen, "Data", sep = "/")

# create directories
dir.create(out_dir_gen, showWarnings = FALSE)
dir.create(out_dir_gen_plots, showWarnings = FALSE)
dir.create(out_dir_gen_data, showWarnings = FALSE)
dir.create(paste(params$work_dir, "Contrasts", sep = "/"), showWarnings = FALSE)

```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

### load librarys
```{r echo=show_code}
pacman::p_load(tidyverse, broom, Maaslin2, foreach, doParallel, httr, jsonlite, xml2, EnhancedVolcano, UniProt.ws, ggplot2, pheatmap)
```

### load necessary files
```{r echo=show_code}
counts_df <- read.csv(file = params$counts, row.names = 1, header = TRUE, sep = '\t') 
counts_df <- counts_df[ , order(names(counts_df))]

metadata_df <- read.csv(file = params$metadata, row.names = 1, header = TRUE, sep = ',', stringsAsFactors=FALSE) %>% mutate_if(is.numeric, as.character)
metadata_df <- metadata_df[order(row.names(metadata_df)), ]

comparisons_df <- read.csv(file = params$comparisons, header = TRUE, sep = ',') 
```

### functions
```{r echo=show_code}
plot.volcano <-function(df, title_txt, label_col, subtitle_txt){
  EnhancedVolcano(df,lab = label_col, x = "logFC", y = "qval", ylab = expression(-Log[10]~(p-value)),
                  title = title_txt, subtitle = paste("Volcano plot:", subtitle_txt, ", \u03b1 = ", params$alpha, sep = " "),
                  pCutoff = params$alpha, FCcutoff = params$fc_threshold,
                  colAlpha = 1, boxedLabels = TRUE,
                  drawConnectors = TRUE,
                  widthConnectors = 1.0,
                  colConnectors = 'black',
                  max.overlaps = 30,
                  legendLabels = c('not significant', expression(Log[2]~FC~sig), expression(adj.~p-value~sig), expression(adj.~p-value~and~log[2]~FC~sig)))
}

plot.ma <- function(df, title_txt){
  df$sig <- ifelse(df$qval < params$alpha, "1", "0")
  ggplot() +
    geom_point(data = df, aes(x = count_mean, y = logFC, col = sig), size = 0.5, show.legend = FALSE) +
    ggtitle(paste("MA-Plot:", title_txt, ", \u03b1 = ", params$alpha, sep = " ")) +
    theme(plot.title = element_text(hjust = 0.5)) +
    scale_colour_manual(values = c("1" = "red", "0" = "black")) +
    ylab("log2 fold change") +
    xlab("mean of normalized counts") 
}

plot.pca <- function(df, meta, group, title_txt){
  pca <- prcomp(t(df), center = TRUE, scale = FALSE)
  dtp <- data.frame(meta, pca$x[,1:2])
  ggplot(data = dtp) + 
       geom_point(aes(x = PC1, y = PC2, col = dtp[, group])) + 
       labs(color = group) +
       ggtitle(paste("PCA, colored by", title_txt, sep = " ")) +
       theme(plot.title = element_text(hjust = 0.5)) +
       xlab(paste0("PC1: ",   summary(pca)$importance[2,1], "% variance")) +
       ylab(paste0("PC2: ",   summary(pca)$importance[2,2] ,"% variance")) + 
       coord_fixed()
}

plot.heatmap <- function(df, n, anno, title_txt, cluster_rows = TRUE, cluster_cols = TRUE, group = NA){
  pheatmap(df[1:n, ], scale = "row", annotation_col = group, main = title_txt,
        labels_row = anno[1:n],
        labels_col = as.character(colnames(df)),
        cluster_rows = cluster_rows, 
        cluster_cols = cluster_cols)
}

plot.dist <- function(df, title_txt, group = NA, cluster_cols = FALSE, cluster_rows = FALSE){
  pheatmap(dist(df), cluster_cols = cluster_cols, cluster_rows = cluster_rows,
        scale = "row", main = title_txt,
        labels_row = as.character(rownames(df)),
        labels_col = as.character(rownames(df)),
        annotation_row = group,
        annotation_col = group)
}

uniprot.map <- function(ids1, ids2, from_str, to_str, mapping_df){

  post <- function(f, t, ids){
    response <- POST(url = "https://www.uniprot.org/uploadlists/", body = list(from = f, to = t, format = 'tab', query = paste(ids, collapse = ' ')))
    httr::content(response, type = 'text/tab-separated-values', encoding = "UTF-8")
  }
  if(length(ids1) <= 2){ return(rbind(mapping_df, post(from_str, to_str, ids1))) }
  if(length(ids1) > 5000){ return(uniprot.map(ids1[1:5000],  ids1[5001:length(ids1)], from_str, to_str, mapping_df)) }
  if(length(ids1) <= 5000){
      return(uniprot.map(ids2[1:min(length(ids2), 5000)], ids2[min(length(ids2)+1, 5001):length(ids2)], 
                  from_str, to_str, rbind(mapping_df, post(from_str, to_str, ids1)))) }
}
  
```

## clean row and col names
```{r echo=show_code}
# clean count_df colnames (sample names)
colnames(counts_df) <- gsub(".RPKs", "", colnames(counts_df), fixed = TRUE)
colnames(counts_df) <- gsub("_Abundance", "", colnames(counts_df), fixed = TRUE)

# clean metadata rownames (sample names)
rownames(metadata_df) <- gsub("_", ".", rownames(metadata_df), fixed = TRUE)

```

### remove stratified duplicate hits, low abundant hits and NAs
```{r echo=show_code}
# drop stratified duplicate rows
counts_unstratified_df <- counts_df[!grepl("\\|",rownames(counts_df)),]

# drop rows containing NAs and add pseudo count to prevent MaAslin2 model fit from crashing
counts_clean_df <- na.omit(counts_unstratified_df + 1)

# remove unmapped counts
counts_clean_df <- counts_clean_df[!(row.names(counts_clean_df) %in% "UNMAPPED"), ]

# gene abundance distribution over all samples
hist_plot <- hist(rowSums(counts_clean_df[-1, ]), br = 100, main = "Cleaned gene count distribution over all samples", xlab = "Genes counts")
hist_log_plot <- hist(log2(rowSums(counts_clean_df[-1, ])), br = 100, main = "Log2 transformed, cleaned gene count distribution over all samples", xlab = "Log2 transformed genes counts")
```

### set feature display names
```{r echo=show_code}
# tell tidy to stop spamming my console with col info <3
show_col_types = FALSE

# map uniref IDs to gene name
feature_ids <- unlist(strsplit(rownames(counts_clean_df), "_"))
from <- "NF50"
if(feature_ids[1] == "UniRef90"){ from <- "NF90" }
if(feature_ids[1] == "UniRef100"){ from <- "NF100" }
feature_ids <- feature_ids[!grepl("UniRef", feature_ids)]
feature_ids <- gsub(":.*", "", feature_ids)
feature_ids <- gsub(" .*", "", feature_ids)
feature_names <- read.csv("/home/david/feature_ids.csv")  #uniprot.map(feature_ids, c(), from, "GENENAME", data.frame())
write.csv(feature_names, file = paste(out_dir_gen_data, "feature_id_mapping.csv", sep = "/"))
colnames(feature_names)[1] <- "id"
colnames(feature_names)[2] <- "gene_name"

# add display names to significant features
counts_clean_df$id <- gsub(":.*", "", gsub(".*_", "", rownames(counts_clean_df)))
counts_clean_df$id <- gsub(" .*", "", counts_clean_df$id)
counts_clean_df$feature <- rownames(counts_clean_df)
counts_clean_anno_df <- merge(counts_clean_df, as.data.frame(feature_names), by = "id",  all.x = TRUE)

# do not touch this for the love of god
# add cols for gene name, synonym name and display name, where display name is whatever is available of gene name|synonym, gene name, ID in this order
counts_clean_anno_df$synonym <- ifelse(grepl(":", counts_clean_anno_df$feature), gsub(".*:", "", counts_clean_anno_df$feature), NA)
counts_clean_anno_df$display_name <- ifelse(!is.na(counts_clean_anno_df$synonym), 
                                            ifelse(!is.na(counts_clean_anno_df$gene_name),
                                                   paste(counts_clean_anno_df$gene_name, counts_clean_anno_df$synonym, sep = " | "),
                                                   paste(counts_clean_anno_df$id, counts_clean_anno_df$synonym, sep = " | ")),
                                            ifelse(!is.na(counts_clean_anno_df$gene_name),
                                                   counts_clean_anno_df$gene_name,
                                                   counts_clean_anno_df$id))
counts_clean_anno_df$feature <- gsub(":", ".", counts_clean_anno_df$feature, fixed = TRUE)
counts_clean_anno_df$feature <- gsub(" ", ".", counts_clean_anno_df$feature, fixed = TRUE)
counts_clean_anno_df$feature <- gsub("-", ".", counts_clean_anno_df$feature, fixed = TRUE)
rownames(counts_clean_anno_df) <- counts_clean_anno_df$feature
```

### plots on count data
```{r echo=show_code, message=FALSE}
# sort data by most counts per row
counts_clean_anno_df <- counts_clean_anno_df[order(-rowSums(counts_clean_anno_df[ , 2:(length(counts_clean_anno_df)-4)])), ]
counts_clean_num_df <- counts_clean_anno_df[ , 2:(length(counts_clean_anno_df)-4)]

# general pca colored by sample
metadata_df$sample <- row.names(metadata_df)
pca_gen <- plot.pca(counts_clean_df[, 1:(length(colnames(counts_clean_df)) - 2)], metadata_df, "sample", "sample")
ggsave(filename = "pca_general.png", plot = pca_gen, device = png, path = out_dir_gen_plots, height = params$plot_height, width = params$plot_width)
pca_gen_log <- plot.pca(log2(counts_clean_df[, 1:(length(colnames(counts_clean_df)) - 2)]), metadata_df, "sample", "sample")
ggsave(filename = "pca__log_general.png", plot = pca_gen_log, device = png, path = out_dir_gen_plots, height = params$plot_height, width = params$plot_width)

# heatmap of top 50
heat_gen <- plot.heatmap(counts_clean_num_df, 50, counts_clean_anno_df$display_name, "Heatmap top 50 counts")
ggsave(filename = "heatmap_top_50_count_gen.png", plot = heat_gen, device = png, path = out_dir_gen_plots, height = params$plot_height, width = params$plot_width)
heat_gen_log <- plot.heatmap(log2(counts_clean_num_df), 50, counts_clean_anno_df$display_name, "Heatmap top 50 counts")
ggsave(filename = "heatmap_top_50_count_log_gen.png", plot = heat_gen_log, device = png, path = out_dir_gen_plots, height = params$plot_height, width = params$plot_width)

# sample to sample distance
sample_dist <- plot.dist(t(counts_clean_num_df), "Sample to sample count distance (euclidean)")
ggsave(filename = "sample_to_sample_dist_count.png", plot = sample_dist, device = png, path = out_dir_gen_plots, height = params$plot_height, width = params$plot_width)
sample_dist_log <- plot.dist(t(log2(counts_clean_num_df)), "Sample to sample log count distance (euclidean)")
ggsave(filename = "sample_to_sample_dist_log_count.png", plot = sample_dist_log, device = png, path = out_dir_gen_plots, height = params$plot_height, width = params$plot_width)
```

### run MaAslin2 model for given formula
```{r echo=show_code,  message=FALSE}
# set reference level for each condition assuming first occurence is reference for now
ref_levels <- c()
conditions <- strsplit(params$formula, "\\+")[[1]]
for(i in 1:length(conditions)){
  ref_levels <- rbind(ref_levels, paste(conditions[i], metadata_df[1, conditions[i]], sep = ","))
}

# run model once for given formula, assume first entry in metadata is the reference level
sink("/dev/null") # make maaslin2 shut up for once
fit <- Maaslin2(
    input_data = counts_clean_anno_df, 
    input_metadata = metadata_df, 
    output = paste(out_dir_gen_data, "maaslin2_model_output", sep = "/"),
    analysis_method = "CPLM",
    normalization = "NONE",
    transform = "NONE",
    fixed_effects = strsplit(params$formula, "\\+")[[1]],
    reference = paste(ref_levels, collapse = ";"),
    cores = params$cpus,
    min_abundance = params$abundance_threshold,
    min_prevalence = params$prevalence_threshold,
    plot_scatter = FALSE)
sink() 

results_df <- fit$results
results_df <- na.omit(results_df)
results_df <- merge(results_df, counts_clean_anno_df, all.x = TRUE)
results_df <- mutate(results_df, count_mean = rowMeans(results_df[ , 12:(length(results_df)-3)]))
results_df <- mutate(results_df, logFC = log2(exp(results_df$coef))) 

ma_plot_gen <- plot.ma(results_df, "all groups")
ggsave(filename = "ma_plot_general.png", plot = ma_plot_gen, device = png, path = out_dir_gen_plots, height = params$plot_height, width = params$plot_width)

volcano_plot_gen <- plot.volcano(results_df, "Total differential abundant features", results_df$display_name, "all groups")
ggsave(filename = "volcano_plot_general.png", plot = volcano_plot_gen, device = png, path = out_dir_gen_plots, width = 15, height = 10)
```

### run comparisons
```{r echo=show_code}
logFC_by_cond <- as.data.frame(rownames(counts_clean_anno_df))
colnames(logFC_by_cond)[1] <- "feature"

for(i in 1:length(rownames(comparisons_df))){
  
  cond <- comparisons_df$Condition[i]
  ref <- comparisons_df$Group1[i]
  alt <- comparisons_df$Group2[i]
  
  # create directory structure for current contrast 
  contrast <- paste(ref, "vs", alt, sep = "_")
  out_dir_con <- paste(params$work_dir, "Contrasts", contrast, sep = "/")
  dir.create(out_dir_con, showWarnings = FALSE)
  
  out_dir_con_plots <- paste(out_dir_con, "Plots", sep = "/")
  dir.create(out_dir_con_plots, showWarnings = FALSE)
  
  # select rows with current condition
  results_cond_df <- results_df[results_df$metadata %in% cond, ]
  
  # save logFC for this condition for later heatmap
  if(!(cond %in% colnames(logFC_by_cond))){
    temp <- as.data.frame(results_df$logFC)
    temp$feature <- rownames(results_df)
    colnames(temp)[1] <- cond 
    logFC_by_cond <- merge(logFC_by_cond, temp, by = "feature", all = TRUE)
  }
  # filter for significance
  res_sig_df <- results_cond_df[ results_cond_df$qval < params$alpha, ]

  # order by ascending adjusted pval and descending logFC
  res_sig_ordered_df <- res_sig_df[order(res_sig_df$qval, -abs(res_sig_df$logFC)), ]

  # get top 100 significant features ordered by logFC
  top_100_df <- res_sig_ordered_df[1:min(nrow(res_sig_ordered_df), 100), ]
  write.csv(top_100_df, file = paste(out_dir_con, paste(contrast, "top_100_features.csv", sep = "_"), sep = "/"))

  # plot pca colored by current condition
  pca_con <- plot.pca(counts_clean_df[, 1:(length(colnames(counts_clean_df)) - 2)], metadata_df, cond, cond)
  ggsave(filename = paste(contrast, "pca.png"), plot = pca_con, device = png, path = out_dir_con_plots, height = params$plot_height, width = params$plot_width)
  pca_con_log <- plot.pca(log2(counts_clean_df[, 1:(length(colnames(counts_clean_df)) - 2)]), metadata_df, cond, cond)
  ggsave(filename = paste(contrast, "pca_log.png"), plot = pca_con_log, device = png, path = out_dir_con_plots, height = params$plot_height, width = params$plot_width)
  
  # heatmap of top 50
  top_100_anno_df <- merge(top_100_df, counts_clean_anno_df, all.x = TRUE)
  top_100_num_df <- top_100_anno_df[ , 3:(length(top_100_anno_df)-14)]
  
  groups <- data.frame(metadata_df[[cond]])
  colnames(groups)[1] <- cond
  rownames(groups) <- rownames(metadata_df)
  heat_con <- plot.heatmap(top_100_num_df, min(nrow(top_100_num_df), 50), top_100_anno_df$display_name, paste("Heatmap of top 50 significant feature counts by logFC colored by", cond, sep = " "), group = groups)
  ggsave(filename = paste(contrast, "heatmap_top_50_count_by_FC.png", sep = "_"), plot = heat_con, device = png, path = out_dir_con_plots, height = params$plot_height, width = params$plot_width)
  heat_con_log <- plot.heatmap(log2(counts_clean_num_df), min(nrow(top_100_num_df), 50), top_100_anno_df$display_name, paste("Heatmap of top 50 significant feature counts by logFC colored by", cond, "(log)", sep = " "), group = groups)
  ggsave(filename = paste(contrast, "heatmap_top_50_log_count_by_FC.png", sep = "_"), plot = heat_con_log, device = png, path = out_dir_con_plots, height = params$plot_height, width = params$plot_width)
  
  # sample to sample distance
  sample_dist_con <- plot.dist(t(top_100_num_df), paste("Sample to sample count distance colored by ", cond, "(euclidean)", sep = " "), group = groups, TRUE, TRUE)
  ggsave(filename = paste(contrast, "sample_to_sample_dist_count.png", sep = "_"), plot = sample_dist_con, device = png, path = out_dir_con_plots, height = params$plot_height, width = params$plot_width)
  sample_dist_log <- plot.dist(t(log2(counts_clean_num_df)), paste("Sample to sample log count distance colored by ", cond, "(euclidean)", sep = " "), group = groups, TRUE, TRUE)
  ggsave(filename = paste(contrast, "sample_to_sample_dist_log_count.png", sep = "_"), plot = sample_dist_log, device = png, path = out_dir_con_plots, height = params$plot_height, width = params$plot_width)
  
}

rownames(logFC_by_cond) <- logFC_by_cond$feature
logFC_by_cond <- logFC_by_cond[-1]
logFC_by_cond <- logFC_by_cond[rowSums(is.na(logFC_by_cond)) != ncol(logFC_by_cond), ]
```

### run comparisons
```{r echo=params$show_code}
# setup backend for parallel execution
cl <- makeCluster(min(params$cpus, length(comparisons_ls))) #, outfile=""
registerDoParallel(cl)

# do each comparison in one thread
worker_array <- foreach(i = 1:length(rownames(comparisons_df)), .packages = c("Maaslin2", "EnhancedVolcano", "httr", "dplyr", "ggplot2", "pheatmap")) %dopar% {
  
  reference <- comparisons_df$Group1[i]
  altered <- comparisons_df$Group2[i]

  out_dir <- paste(reference, "vs", altered, sep = "_")

# only run if we cant derive the effect for new reference level from the first model
  #fit <- Maaslin2(
  #  input_data = counts_clean_df, 
  #  input_metadata = metadata_df, 
  #  output = out_dir,
  # analysis_method = "CPLM",
  #  normalization = "NONE",
  #  transform = "NONE",
  #  fixed_effects = gsub(":",",",comparisons_ls[i], fixed = TRUE),
  #  cores = 1,
  #  plot_scatter = FALSE)
  
  #gc()
  
  # get results and calculate log fold change and count mean row wise
  
}

stopCluster(cl)
```

```{r echo=show_code}

```

```{r echo=params$show_code}

```

```{r echo=params$show_code}

```

```{r echo=params$show_code}

```
