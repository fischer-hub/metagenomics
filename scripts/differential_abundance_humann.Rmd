---
title: "Differential Abundance Analysis: Humann3"
author: "David Fischer"
date: "04.02.2022"
output: html_document
params:
  counts: "/home/david/bachelorarbeit/metagenomics/assets/genefamilies_cpm_combined.tsv"
  metadata: "/home/david/bachelorarbeit/metagenomics/assets/SraRunTable.txt"
  show_code: TRUE
  comparisons: "/home/david/bachelorarbeit/metagenomics/assets/contrast.csv"
  formula: "sex+antibiotic_12m+Fam_hx_stone+diet_type"
  cpus: 8
  abundance_threshold: 10
  prevalence_threshold: 0.0001
  alpha: 0.05
  fc_threshold: 1
  work_dir: "/home/david/abundance_analysis"
  plot_height: 11 
  plot_width: 11
---

```{r setup, include=FALSE}
# run with: Rscript -e "rmarkdown::render('differential_abundance_humann.Rmd',params=list(counts = '', metadata = ''))"
knitr::opts_chunk$set(echo = TRUE)

# set directory variables
out_dir_gen <-paste(params$work_dir, "Overview", sep = "/")
out_dir_gen_plots <-paste(out_dir_gen, "Plots", sep = "/")
out_dir_gen_data <-paste(out_dir_gen, "Data", sep = "/")

# create directories
dir.create(out_dir_gen, showWarnings = FALSE)
dir.create(out_dir_gen_plots, showWarnings = FALSE)
dir.create(out_dir_gen_data, showWarnings = FALSE)
dir.create(paste(params$work_dir, "Contrasts", sep = "/"), showWarnings = FALSE)

```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

### load librarys
```{r echo=params$show_code}
library(tidyverse)
library(broom)
library(Maaslin2)
library(foreach)
library(doParallel)
library(httr)
library(jsonlite)
library(xml2)
library(EnhancedVolcano)
library(UniProt.ws)
library(ggplot2)
library(pheatmap)
```

### load necessary files
```{r echo=params$show_code}
counts_df <- read.csv(file = params$counts, row.names = 1, header = TRUE, sep = '\t') 
counts_df <- counts_df[ , order(names(counts_df))]

metadata_df <- read.csv(file = params$metadata, row.names = 1, header = TRUE, sep = ',', stringsAsFactors=FALSE) %>% mutate_if(is.numeric, as.character)
metadata_df <- metadata_df[order(row.names(metadata_df)), ]

comparisons_df <- read.csv(file = params$comparisons, header = TRUE, sep = ',') 
```

### functions
```{r echo=params$show_code}

# create flag in case the script exits early
file.create("dga_humann.done")

plot.volcano <-function(df, title_txt, label_col, subtitle_txt){
  EnhancedVolcano(df,lab = label_col, x = "logFC", y = "qval", ylab = expression(-Log[10]~(p-value)),
                  title = title_txt, subtitle = paste("Volcano plot:", subtitle_txt, ", \u03b1 = ", params$alpha, sep = " "),
                  pCutoff = params$alpha, FCcutoff = params$fc_threshold,
                  colAlpha = 1, boxedLabels = TRUE,
                  drawConnectors = TRUE,
                  widthConnectors = 1.0,
                  colConnectors = 'black',
                  max.overlaps = 30,
                  legendLabels = c('not significant', expression(Log[2]~FC~sig), expression(adj.~p-value~sig), expression(adj.~p-value~and~log[2]~FC~sig)))
}

plot.ma <- function(df, title_txt){
  df$sig <- ifelse(df$qval < params$alpha, "1", "0")
  ggplot() +
    geom_point(data = df, aes(x = count_mean, y = logFC, col = sig), size = 0.5, show.legend = FALSE) +
    ggtitle(paste("MA-Plot:", title_txt, ", \u03b1 = ", params$alpha, sep = " ")) +
    theme(plot.title = element_text(hjust = 0.5)) +
    scale_colour_manual(values = c("1" = "red", "0" = "black")) +
    ylab("log2 fold change") +
    xlab("mean of normalized counts") 
}

plot.pca <- function(df, meta, group, title_txt){
  pca <- prcomp(t(df), center = TRUE, scale = FALSE)
  dtp <- data.frame(meta, pca$x[,1:2])
  ggplot(data = dtp) + 
       geom_point(aes(x = PC1, y = PC2, col = dtp[, group])) + 
       labs(color = group) +
       ggtitle(paste("PCA, colored by", title_txt, sep = " ")) +
       theme(plot.title = element_text(hjust = 0.5)) +
       xlab(paste0("PC1: ",   summary(pca)$importance[2,1], "% variance")) +
       ylab(paste0("PC2: ",   summary(pca)$importance[2,2] ,"% variance")) + 
       coord_fixed()
}

plot.heatmap <- function(df, n, anno, title_txt, cluster_rows = TRUE, cluster_cols = TRUE, group = NA){
  pheatmap(df[1:n, ], scale = "row", annotation_col = group, main = title_txt,
        labels_row = anno[1:n],
        labels_col = as.character(colnames(df)),
        cluster_rows = cluster_rows, 
        cluster_cols = cluster_cols)
}

plot.dist <- function(df, title_txt, group = NA, cluster_cols = FALSE, cluster_rows = FALSE){
  pheatmap(dist(df), cluster_cols = cluster_cols, cluster_rows = cluster_rows,
        scale = "row", main = title_txt,
        labels_row = as.character(rownames(df)),
        labels_col = as.character(rownames(df)),
        annotation_row = group,
        annotation_col = group)
}

uniprot.map <- function(ids1, ids2, from_str, to_str, mapping_df){

  post <- function(f, t, ids){
    response <- POST(url = "https://www.uniprot.org/uploadlists/", body = list(from = f, to = t, format = 'tab', query = paste(ids, collapse = ' ')))
    httr::content(response, type = 'text/tab-separated-values', encoding = "UTF-8")
  }
  if(length(ids1) <= 2){ return(rbind(mapping_df, post(from_str, to_str, ids1))) }
  if(length(ids1) > 5000){ return(uniprot.map(ids1[1:5000],  ids1[5001:length(ids1)], from_str, to_str, mapping_df)) }
  if(length(ids1) <= 5000){
      return(uniprot.map(ids2[1:min(length(ids2), 5000)], ids2[min(length(ids2)+1, 5001):length(ids2)], 
                  from_str, to_str, rbind(mapping_df, post(from_str, to_str, ids1)))) }
  
  catch_empty_df <- function(df){
    if(nrows(df) <=1 ){
      print("Oopsie, seems like there is no data in here..\n This means that either the input data is empty, or all feature counts were filtered out because of low abundance or significance.\nYou can try to change the thresholds for these values [fc_th, ab_th, pr_th, sig_th] in the config file under profiles/config.yaml !")
      quit(save = "no", status = 0)
    }
  }
}
  
```

## clean row and col names
```{r echo=params$show_code}
# clean count_df colnames (sample names)
catch_empty_df(counts_df)
colnames(counts_df) <- gsub(".RPKs", "", colnames(counts_df), fixed = TRUE)
colnames(counts_df) <- gsub("_Abundance", "", colnames(counts_df), fixed = TRUE)

# clean metadata rownames (sample names)
catch_empty_df(metadata_df)
rownames(metadata_df) <- gsub("_", ".", rownames(metadata_df), fixed = TRUE)

```

### remove stratified duplicate hits, low abundant hits and NAs
```{r echo=params$show_code}
# drop stratified duplicate rows
counts_unstratified_df <- counts_df[!grepl("\\|",rownames(counts_df)),]

# drop rows containing NAs and add pseudo count to prevent MaAslin2 model fit from crashing
counts_clean_df <- na.omit(counts_unstratified_df + 1)

# remove unmapped counts
counts_clean_df <- counts_clean_df[!(row.names(counts_clean_df) %in% "UNMAPPED"), ]

# gene abundance distribution over all samples
hist_plot <- hist(rowSums(counts_clean_df[-1, ]), br = 100, main = "Cleaned gene count distribution over all samples", xlab = "Genes counts")
hist_log_plot <- hist(log2(rowSums(counts_clean_df[-1, ])), br = 100, main = "Log2 transformed, cleaned gene count distribution over all samples", xlab = "Log2 transformed genes counts")
```

### set feature display names
```{r echo=params$show_code}
# tell tidy to stop spamming my console with col info <3
show_col_types = FALSE

# map uniref IDs to gene name
feature_ids <- unlist(strsplit(rownames(counts_clean_df), "_"))
from <- "NF50"
if(feature_ids[1] == "UniRef90"){ from <- "NF90" }
if(feature_ids[1] == "UniRef100"){ from <- "NF100" }
feature_ids <- feature_ids[!grepl("UniRef", feature_ids)]
feature_ids <- gsub(":.*", "", feature_ids)
feature_ids <- gsub(" .*", "", feature_ids)
feature_names <- read.csv("/home/david/feature_ids.csv")  #uniprot.map(feature_ids, c(), from, "GENENAME", data.frame())
write.csv(feature_names, file = paste(out_dir_gen_data, "feature_id_mapping.csv", sep = "/"))
colnames(feature_names)[1] <- "id"
colnames(feature_names)[2] <- "gene_name"

# add display names to significant features
counts_clean_df$id <- gsub(":.*", "", gsub(".*_", "", rownames(counts_clean_df)))
counts_clean_df$id <- gsub(" .*", "", counts_clean_df$id)
counts_clean_df$feature <- rownames(counts_clean_df)
counts_clean_anno_df <- merge(counts_clean_df, as.data.frame(feature_names), by = "id",  all.x = TRUE)

# do not touch this for the love of god
# add cols for gene name, synonym name and display name, where display name is whatever is available of gene name|synonym, gene name, ID in this order
counts_clean_anno_df$synonym <- ifelse(grepl(":", counts_clean_anno_df$feature), gsub(".*:", "", counts_clean_anno_df$feature), NA)
counts_clean_anno_df$display_name <- ifelse(!is.na(counts_clean_anno_df$synonym), 
                                            ifelse(!is.na(counts_clean_anno_df$gene_name),
                                                   paste(counts_clean_anno_df$gene_name, counts_clean_anno_df$synonym, sep = " | "),
                                                   paste(counts_clean_anno_df$id, counts_clean_anno_df$synonym, sep = " | ")),
                                            ifelse(!is.na(counts_clean_anno_df$gene_name),
                                                   counts_clean_anno_df$gene_name,
                                                   counts_clean_anno_df$id))
counts_clean_anno_df$feature <- gsub(":", ".", counts_clean_anno_df$feature, fixed = TRUE)
counts_clean_anno_df$feature <- gsub(" ", ".", counts_clean_anno_df$feature, fixed = TRUE)
counts_clean_anno_df$feature <- gsub("-", ".", counts_clean_anno_df$feature, fixed = TRUE)
rownames(counts_clean_anno_df) <- counts_clean_anno_df$feature
```

### plots on count data
```{r echo=params$show_code, message=FALSE}
# sort data by most counts per row
counts_clean_anno_df <- counts_clean_anno_df[order(-rowSums(counts_clean_anno_df[ , 2:(length(counts_clean_anno_df)-4)])), ]
counts_clean_num_df <- counts_clean_anno_df[ , 2:(length(counts_clean_anno_df)-4)]

# general pca colored by sample
metadata_df$sample <- row.names(metadata_df)
pca_gen <- plot.pca(counts_clean_df[, 1:(length(colnames(counts_clean_df)) - 2)], metadata_df, "sample", "sample")
ggsave(filename = "pca_general.png", plot = pca_gen, device = png, path = out_dir_gen_plots, height = params$plot_height, width = params$plot_width)
pca_gen_log <- plot.pca(log2(counts_clean_df[, 1:(length(colnames(counts_clean_df)) - 2)]), metadata_df, "sample", "sample")
ggsave(filename = "pca__log_general.png", plot = pca_gen_log, device = png, path = out_dir_gen_plots, height = params$plot_height, width = params$plot_width)

# heatmap of top 50
heat_gen <- plot.heatmap(counts_clean_num_df, 50, counts_clean_anno_df$display_name, "Heatmap top 50 counts")
ggsave(filename = "heatmap_top_50_count_gen.png", plot = heat_gen, device = png, path = out_dir_gen_plots, height = params$plot_height, width = params$plot_width)
heat_gen_log <- plot.heatmap(log2(counts_clean_num_df), 50, counts_clean_anno_df$display_name, "Heatmap top 50 counts")
ggsave(filename = "heatmap_top_50_count_log_gen.png", plot = heat_gen_log, device = png, path = out_dir_gen_plots, height = params$plot_height, width = params$plot_width)

# sample to sample distance
sample_dist <- plot.dist(t(counts_clean_num_df), "Sample to sample count distance (euclidean)")
ggsave(filename = "sample_to_sample_dist_count.png", plot = sample_dist, device = png, path = out_dir_gen_plots, height = params$plot_height, width = params$plot_width)
sample_dist_log <- plot.dist(t(log2(counts_clean_num_df)), "Sample to sample log count distance (euclidean)")
ggsave(filename = "sample_to_sample_dist_log_count.png", plot = sample_dist_log, device = png, path = out_dir_gen_plots, height = params$plot_height, width = params$plot_width)
```

### run MaAslin2 model for given formula
```{r echo=params$show_code,  message=FALSE}
# set reference level for each condition assuming first occurence is reference for now
ref_levels <- c()
conditions <- strsplit(params$formula, "\\+")[[1]]
for(i in 1:length(conditions)){
  ref_levels <- rbind(ref_levels, paste(conditions[i], metadata_df[1, conditions[i]], sep = ","))
}

# run model once for given formula, assume first entry in metadata is the reference level
sink("/dev/null") # make maaslin2 shut up for once
fit <- Maaslin2(
    input_data = counts_clean_anno_df, 
    input_metadata = metadata_df, 
    output = paste(out_dir_gen_data, "maaslin2_model_output", sep = "/"),
    analysis_method = "CPLM",
    normalization = "NONE",
    transform = "NONE",
    fixed_effects = strsplit(params$formula, "\\+")[[1]],
    reference = paste(ref_levels, collapse = ";"),
    cores = params$cpus,
    min_abundance = params$abundance_threshold,
    min_prevalence = params$prevalence_threshold,
    plot_scatter = FALSE)
sink() 

results_df <- fit$results
results_df <- na.omit(results_df)
catch_empty_df(results_df)
results_df <- merge(results_df, counts_clean_anno_df, all.x = TRUE)
results_df <- mutate(results_df, count_mean = rowMeans(results_df[ , 12:(length(results_df)-3)]))
results_df <- mutate(results_df, logFC = log2(exp(results_df$coef))) 

ma_plot_gen <- plot.ma(results_df, "all groups")
ggsave(filename = "ma_plot_general.png", plot = ma_plot_gen, device = png, path = out_dir_gen_plots, height = params$plot_height, width = params$plot_width)

volcano_plot_gen <- plot.volcano(results_df, "Total differential abundant features", results_df$display_name, "all groups")
ggsave(filename = "volcano_plot_general.png", plot = volcano_plot_gen, device = png, path = out_dir_gen_plots, width = 15, height = 10)
```

### run comparisons
```{r echo=params$show_code}
logFC_by_cond <- as.data.frame(rownames(counts_clean_anno_df))
colnames(logFC_by_cond)[1] <- "feature"

cl <- makeCluster(min(params$cpus, nrow(comparisons_df))) #, outfile=""
registerDoParallel(cl)

worker_array <- foreach(i = 1:nrow(comparisons_df), .combine = 'rbind', .packages = c("Maaslin2", "EnhancedVolcano", "pheatmap", "tidyverse"), outfile="") %dopar% {
  
  cond <- comparisons_df$Condition[i]
  ref <- comparisons_df$Group1[i]
  alt <- comparisons_df$Group2[i]
  
  # CONTRAST BASED MAASLIN2 CALL HERE
  catch_empty_df(results_df)

  # create directory structure for current contrast 
  contrast <- paste(ref, "vs", alt, sep = "_")
  out_dir_con <- paste(params$work_dir, "Contrasts", contrast, sep = "/")
  dir.create(out_dir_con, showWarnings = FALSE)
  
  out_dir_con_plots <- paste(out_dir_con, "Plots", sep = "/")
  dir.create(out_dir_con_plots, showWarnings = FALSE)
  
  out_dir_con_data <- paste(out_dir_con, "Data", sep = "/")
  dir.create(out_dir_con_data, showWarnings = FALSE)
  
  # run model once for each contrast, assume Group1 from contrast sheet is the reference level
  sink("/dev/null") # make maaslin2 shut up for once
  fit <- Maaslin2(
      input_data = counts_clean_anno_df, 
      input_metadata = metadata_df, 
      output = paste(out_dir_con_data, paste(contrast, "maaslin2_model_output", sep = "_"), sep = "/"),
      analysis_method = "CPLM",
      normalization = "NONE",
      transform = "NONE",
      fixed_effects = cond,
      reference = paste(cond, ref, sep = ","),
      cores = 1,
      min_abundance = params$abundance_threshold,
      min_prevalence = params$prevalence_threshold,
      plot_scatter = FALSE)
  sink() 
  
  # select rows with current condition
  results_cond_df <- fit$results #results_df[results_df$metadata %in% cond, ]
  
  # get display names, logFC and mean of normalized counts
  results_cond_df <- merge(results_cond_df, counts_clean_anno_df, all.x = TRUE)
  results_cond_df <- mutate(results_cond_df, count_mean = rowMeans(results_cond_df[ , 12:(length(results_cond_df)-3)]))
  results_cond_df <- mutate(results_cond_df, logFC = log2(exp(results_cond_df$coef)))
  
  # save logFC for this contrast for later heatmap
  temp <- as.data.frame(results_cond_df[results_cond_df$value %in% alt  , "logFC"])
  temp$feature <- results_cond_df[results_cond_df$value %in% alt  , "feature"]
  temp$qval <- results_cond_df[results_cond_df$value %in% alt  , "qval"]
  colnames(temp)[c(1,2,3)] <- c(contrast, "feature", paste("qval", contrast, sep = "_"))

  # filter for significance
  res_sig_df <- results_cond_df[ results_cond_df$qval < params$alpha, ]

  # order by ascending adjusted pval and descending logFC
  res_sig_ordered_df <- res_sig_df[order(res_sig_df$qval, -abs(res_sig_df$logFC)), ]

  # get top 100 significant features ordered by logFC
  top_100_df <- res_sig_ordered_df[1:min(nrow(res_sig_ordered_df), 100), ]
  write.csv(top_100_df, file = paste(out_dir_con_data, paste(contrast, "top_100_features.csv", sep = "_"), sep = "/"))

  # plot pca colored by current condition
  pca_con <- plot.pca(counts_clean_df[, 1:(length(colnames(counts_clean_df)) - 2)], metadata_df, cond, cond)
  ggsave(filename = paste(contrast, "pca.png"), plot = pca_con, device = png, path = out_dir_con_plots, height = params$plot_height, width = params$plot_width)
  pca_con_log <- plot.pca(log2(counts_clean_df[, 1:(length(colnames(counts_clean_df)) - 2)]), metadata_df, cond, cond)
  ggsave(filename = paste(contrast, "pca_log.png"), plot = pca_con_log, device = png, path = out_dir_con_plots, height = params$plot_height, width = params$plot_width)
  
  # heatmap of top 50
  top_100_anno_df <- merge(top_100_df, counts_clean_anno_df, all.x = TRUE)
  top_100_num_df <- top_100_anno_df[ , 3:(ncol(top_100_anno_df)-14)]
  
  groups <- data.frame(metadata_df[[cond]])
  colnames(groups)[1] <- cond
  rownames(groups) <- rownames(metadata_df)
  heat_con <- plot.heatmap(top_100_num_df, min(nrow(top_100_num_df), 50), top_100_anno_df$display_name, paste("Heatmap of top 50 significant feature counts by logFC colored by", cond, sep = " "), group = groups)
  ggsave(filename = paste(contrast, "heatmap_top_50_count_by_FC.png", sep = "_"), plot = heat_con, device = png, path = out_dir_con_plots, height = params$plot_height, width = params$plot_width)
  heat_con_log <- plot.heatmap(log2(counts_clean_num_df), min(nrow(top_100_num_df), 50), top_100_anno_df$display_name, paste("Heatmap of top 50 significant feature counts by logFC colored by", cond, "(log)", sep = " "), group = groups)
  ggsave(filename = paste(contrast, "heatmap_top_50_log_count_by_FC.png", sep = "_"), plot = heat_con_log, device = png, path = out_dir_con_plots, height = params$plot_height, width = params$plot_width)
  
  # sample to sample distance
  sample_dist_con <- plot.dist(t(top_100_num_df), paste("Sample to sample count distance colored by ", cond, "(euclidean)", sep = " "), group = groups, TRUE, TRUE)
  ggsave(filename = paste(contrast, "sample_to_sample_dist_count.png", sep = "_"), plot = sample_dist_con, device = png, path = out_dir_con_plots, height = params$plot_height, width = params$plot_width)
  sample_dist_log <- plot.dist(t(log2(counts_clean_num_df)), paste("Sample to sample log count distance colored by ", cond, "(euclidean)", sep = " "), group = groups, TRUE, TRUE)
  ggsave(filename = paste(contrast, "sample_to_sample_dist_log_count.png", sep = "_"), plot = sample_dist_log, device = png, path = out_dir_con_plots, height = params$plot_height, width = params$plot_width)
  
  # volcano plot for current contrast
  volcano_plot_con <- plot.volcano(results_cond_df[results_cond_df$value %in% alt , ], "Differential abundant features by contrast", results_cond_df[results_cond_df$value %in% alt  , "display_name"], contrast)
  ggsave(filename = paste(contrast, "volcano_plot.png", sep = "_"), plot = volcano_plot_gen, device = png, path = out_dir_con_plots, width = 15, height = 10)
  
  # ma-plot for curretn contrast
  ma_plot_con <- plot.ma(results_cond_df, contrast)
  ggsave(filename = paste(contrast, "ma_plot.png", sep = "_"), plot = ma_plot_con, device = png, path = out_dir_gen_plots, height = params$plot_height, width = params$plot_width)
  
  return(merge(logFC_by_cond, temp, by = "feature", all = TRUE))

}

stopCluster(cl)

rownames(logFC_by_cond) <- logFC_by_cond$feature
logFC_by_cond <- logFC_by_cond[-1]

# remove rows with only NA
logFC_by_cond <- logFC_by_cond[rowSums(is.na(logFC_by_cond)) != ncol(logFC_by_cond), ]

# sort by ascending qval and descending abs(logFC)
logFC_by_cond <- logFC_by_cond[order(-rowSums(abs(logFC_by_cond[ , seq(1, ncol(logFC_by_cond), 2)])),
                                     rowSums(logFC_by_cond[ , seq(2, ncol(logFC_by_cond), 2)])), ]
logFC_by_cond_num <- logFC_by_cond[ , seq(1, ncol(logFC_by_cond), 2)]
# get display names
logFC_by_cond <- merge(logFC_by_cond, counts_clean_anno_df, by.x = 0, by.y = 0, all.x = TRUE)

# heatmap of top significant and expressed features by contrasts
heat_FC <- plot.heatmap(logFC_by_cond_num, min(nrow(logFC_by_cond_num), 50), logFC_by_cond$display_name, "Heatmap of top 50 significant, expressed features by contrasts")
ggsave(filename = "heatmap_top_50_FC_by_contrast.png", plot = heat_FC, device = png, path = out_dir_gen_plots, height = params$plot_height, width = params$plot_width)

# pca of top significant and expressed features by contrasts
temp <- as.data.frame(colnames(logFC_by_cond_num))
colnames(temp)[1] <- "contrast"
pca_FC <- plot.pca(logFC_by_cond_num, temp, "contrast", "contrast")
  ggsave(filename = "contrasts_pca.png", plot = pca_FC, device = png, path = out_dir_gen_plots, height = params$plot_height, width = params$plot_width)
```
